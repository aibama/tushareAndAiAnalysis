当前的日线数据的表结构如下：
CREATE TABLE `stocktradetodayinfo` (
  `id` decimal(16,2) DEFAULT NULL,
  `ts_code` varchar(255) NOT NULL,
  `amount` decimal(16,3) DEFAULT NULL,
  `echange` float DEFAULT NULL,
  `close` float DEFAULT NULL,
  `high` float DEFAULT NULL,
  `low` float DEFAULT NULL,
  `open` float DEFAULT NULL,
  `pct_chg` float DEFAULT NULL,
  `pre_close` float DEFAULT NULL,
  `trade_date` datetime(6) DEFAULT NULL,
  `vol` decimal(16,2) DEFAULT NULL,
  `trade_date_tmp` datetime(6) DEFAULT NULL,
  KEY `idx_stocktradedailyinfo_trade_date` (`trade_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
有到今年1月份的数据，按下面的需求，在PatternAnalysis目录下进行功能开发。需考虑增量数据后，进行的个股数据补全，从而导致分类任务的重新启动，使用如下的技术路线：
数据层 → 特征工程 → AI模型 → 服务部署 → 应用层
  ↓         ↓         ↓         ↓         ↓
日线数据 → 形态编码 → 模型训练 → API服务 → Web界面
              ↓         ↓         ↓
        技术指标 → 混合模型 → 实时推理
另外进行训练和本地启动部署的机器显卡有6GB，注意资源限制。
需要实现的功能需求：
在给定时间周期里面的（3个月，6个月，9个月，1年，自定义时间），给出所有股票按下面进行
    1: "单边上涨",
    2: "单边下跌", 
    3: "上升三角形",
    4: "下降三角形",
    5: "对称三角形",
    6: "杯状带柄",
    7: "头肩顶",
    8: "头肩底"
	9: "圆弧顶",
    10: "圆弧底",
	11: "其他形态"
其他；
进行分类的接口，该接口内需给出分类下的股票列表，列表里的每个股票，在给定时间周期里面的的涨跌幅（如3个月，就是最近一天的交易日的收盘价到3个月前的首天的收盘价的涨跌幅），
上一个时间周期里面的的涨跌幅（如果给定时间周期里面是3个月，上个时间周期就是4个月前最后一天到6个月前的首天的收盘价的涨跌幅，如此类推）；
整体思路概览
在不改动你现有日线表结构的前提下，可以在 PatternAnalysis 目录下按下面的分层来实现：
数据层：从 stocktradetodayinfo 拉取指定周期、指定股票的 K 线数据
特征工程 / 形态编码：把一段时间的价格序列 + 技术指标编码成模型输入
AI 模型：11 分类（单边/三角形/杯柄/头肩/圆弧/其他）
服务部署：FastAPI 提供分类接口
应用层：Web 界面调用接口，展示分类结果和两个周期的涨跌幅
另外增加一套 增量数据调度逻辑，在有新日线数据插入后，对受影响个股的形态分类任务做“增量补全+必要的重算”。
下面我给出一个可以直接在 PatternAnalysis 下实现的参考结构和关键代码示例，你可以按需调整文件名。
一、目录与模块建议
在 PatternAnalysis 下新建结构（示例）：
PatternAnalysis/
data_access.py：数据库连接与基础查询
periods.py：时间周期计算（3/6/9/12 个月、自定义）
returns.py：涨跌幅计算
feature_engineering.py：技术指标与形态编码
pattern_model.py：模型加载与推理（可先用规则版占位）
incremental_jobs.py：增量数据下的重算/补全逻辑
api_service.py：FastAPI 接口（形态分类 + 股票列表 + 涨跌幅）
config.py：数据库、模型路径等配置
二、时间周期与涨跌幅计算设计
1. 时间周期规则
假设数据库里最新交易日为 $T$（max(trade_date)）：
给定周期长度 $L$（单位：月）：
当前周期：$[T-L, T]$ 对应的交易日区间
上一个周期：$[T-2L, T-L)$ 对应的交易日区间
你在问题中的 3 个月例子可以理解为：
当前 3 个月：最近一天到 3 个月前首日
上一 3 个月：4–6 个月前这段区间（即紧邻的前一 3 个月）
可以用 Python 来统一计算这两个区间（以自然月为单位）：
# PatternAnalysis/periods.pyfrom datetime import datetime, date, timedeltafrom dateutil.relativedelta import relativedelta  # pip install python-dateutilfrom typing import Tupledef get_period_windows(end_date: date, months: int) -> Tuple[Tuple[date, date], Tuple[date, date]]:    """    :param end_date: 最新交易日（如从 DB max(trade_date) 获取的日期部分）    :param months: 周期月份数，如 3/6/9/12    :return: ((curr_start, curr_end), (prev_start, prev_end))    """    curr_end = end_date    curr_start = end_date - relativedelta(months=months) + timedelta(days=1)    prev_end = curr_start - timedelta(days=1)    prev_start = prev_end - relativedelta(months=months) + timedelta(days=1)    return (curr_start, curr_end), (prev_start, prev_end)
自定义时间周期可以直接传入 start_date、end_date，同样按上面逻辑向前平移一个同长度区间得到“上一个周期”。
2. 涨跌幅计算
当前周期涨跌幅
用当前周期内：首个交易日 close 和 最后一个交易日 close
$ret_{curr} = close_{last} / close_{first} - 1$
上一周期涨跌幅
同理在上一周期内计算 $ret_{prev}$
# PatternAnalysis/returns.pyimport pandas as pdfrom typing import Optionaldef calc_period_return(df: pd.DataFrame) -> Optional[float]:    """    df: 必须按 trade_date 升序，且包含列 'close'    """    if df.empty:        return None    first = df['close'].iloc[0]    last = df['close'].iloc[-1]    if first is None or last is None or first == 0:        return None    return float(last / first - 1.0)
三、数据访问（从 stocktradetodayinfo 拉数据）
# PatternAnalysis/data_access.pyimport pymysqlimport pandas as pdfrom typing import Optional, List, Tuplefrom datetime import datefrom .config import DB_CONFIGdef get_connection():    return pymysql.connect(        host=DB_CONFIG["host"],        port=DB_CONFIG["port"],        user=DB_CONFIG["user"],        password=DB_CONFIG["password"],        database=DB_CONFIG["database"],        charset="utf8"    )def get_latest_trade_date() -> Optional[date]:    sql = "SELECT MAX(trade_date) AS max_dt FROM stocktradetodayinfo"    with get_connection() as conn:        df = pd.read_sql(sql, conn)    if df.empty or df['max_dt'].iloc[0] is None:        return None    return df['max_dt'].iloc[0].date()def get_all_ts_codes() -> List[str]:    sql = "SELECT DISTINCT ts_code FROM stocktradetodayinfo"    with get_connection() as conn:        df = pd.read_sql(sql, conn)    return df['ts_code'].tolist()def get_stock_ohlc_in_range(ts_code: str, start: date, end: date) -> pd.DataFrame:    sql = """        SELECT trade_date, open, high, low, close, vol, amount        FROM stocktradetodayinfo        WHERE ts_code = %s AND trade_date >= %s AND trade_date <= %s        ORDER BY trade_date ASC    """    with get_connection() as conn:        df = pd.read_sql(sql, conn, params=[ts_code, start, end])    return df
四、形态编码与模型（先用规则版占位，后续再换 AI 模型）
考虑到 6GB 显卡限制，建议分两步走：
第一阶段：
用规则+技术指标快速实现一个可用的分类器：
“单边上涨/下跌”：用线性回归斜率 + 回撤/反弹比例判断
三角形/杯柄/头肩/圆弧：用局部高低点（峰谷）+ 拟合直线/圆弧的几何特征，大致归类
规则无法识别的归为 “其他形态”
这阶段模型可以写成纯 Python 函数，无需 GPU。
第二阶段（AI 模型）：
把序列标准化到固定长度（例如最近 120 根 K 线重采样到 60–80 点）
拼接：
标准化价格序列
成交量 / 波动率 / N 个技术指标（MA, MACD, RSI, Bollinger 等）
用一个轻量级 1D CNN 或小型 Transformer 做 11 类分类
批大小控制在 32 以下，序列长度不要太长，基本可在 6GB 显卡上训练
规则版占位示例（真正实现可以复杂得多，这里只是给你接口形式和一个可跑的骨架）：
# PatternAnalysis/pattern_model.pyfrom enum import IntEnumimport numpy as npimport pandas as pdfrom typing import Literalclass PatternType(IntEnum):    SINGLE_UP = 1        # 单边上涨    SINGLE_DOWN = 2      # 单边下跌    ASC_TRIANGLE = 3     # 上升三角形    DESC_TRIANGLE = 4    # 下降三角形    SYM_TRIANGLE = 5     # 对称三角形    CUP_HANDLE = 6       # 杯状带柄    HEAD_SHOULDER_TOP = 7  # 头肩顶    HEAD_SHOULDER_BOTTOM = 8  # 头肩底    ROUND_TOP = 9        # 圆弧顶    ROUND_BOTTOM = 10    # 圆弧底    OTHER = 11           # 其他形态def simple_rule_pattern(df: pd.DataFrame) -> PatternType:    """    极简规则示例：    - 用整体斜率+回撤判断单边上涨/下跌    - 其余全部归为 OTHER    """    if df.empty or len(df) < 10:        return PatternType.OTHER    closes = df['close'].values.astype(float)    x = np.arange(len(closes))    # 最小二乘直线拟合    A = np.vstack([x, np.ones(len(x))]).T    slope, _ = np.linalg.lstsq(A, closes, rcond=None)[0]    # 最大回撤 & 最大反弹    max_close = closes.max()    min_close = closes.min()    overall_change = (closes[-1] - closes[0]) / closes[0]    # 简单判断逻辑（阈值后续可调）    if slope > 0 and overall_change > 0.2 and (max_close - min_close) / closes[0] < 0.4:        return PatternType.SINGLE_UP    if slope < 0 and overall_change < -0.2 and (max_close - min_close) / closes[0] < 0.4:        return PatternType.SINGLE_DOWN    # TODO: 在这里增加三角形、杯柄、头肩、圆弧等形态的几何规则或模型预测    return PatternType.OTHERdef classify_pattern(df: pd.DataFrame, mode: Literal["rule", "ai"] = "rule") -> PatternType:    """    对给定周期的一只股票 K 线进行形态分类    - mode="rule"：调用规则版    - mode="ai"：调用训练好的 AI 模型（后续实现）    """    if mode == "rule":        return simple_rule_pattern(df)    else:        # TODO: 加载模型 + 特征工程 + 推理        return simple_rule_pattern(df)  # 先占位
之后你可以再加：
load_trained_model() 加载本地模型（如 torch.load()）
encode_features(df) 返回张量
在 classify_pattern 中调用 GPU 推理。
五、分类接口设计（FastAPI）
示例：在 PatternAnalysis/api_service.py 中实现一个核心接口：
输入：
period_type: "3m" | "6m" | "9m" | "12m" | "custom"
若为 custom，则传 start_date、end_date
输出：
按形态分类的股票列表
每只股票：
ts_code
pattern_type（1–11）
pattern_name
curr_return（当前周期涨跌幅）
prev_return（上一周期涨跌幅）
# PatternAnalysis/api_service.pyfrom fastapi import FastAPI, Queryfrom pydantic import BaseModelfrom typing import List, Dict, Optionalfrom datetime import datefrom .data_access import (    get_latest_trade_date,    get_all_ts_codes,    get_stock_ohlc_in_range,)from .periods import get_period_windowsfrom .returns import calc_period_returnfrom .pattern_model import classify_pattern, PatternTypeapp = FastAPI(title="Pattern Analysis Service")PATTERN_NAME_MAP = {    PatternType.SINGLE_UP: "单边上涨",    PatternType.SINGLE_DOWN: "单边下跌",    PatternType.ASC_TRIANGLE: "上升三角形",    PatternType.DESC_TRIANGLE: "下降三角形",    PatternType.SYM_TRIANGLE: "对称三角形",    PatternType.CUP_HANDLE: "杯状带柄",    PatternType.HEAD_SHOULDER_TOP: "头肩顶",    PatternType.HEAD_SHOULDER_BOTTOM: "头肩底",    PatternType.ROUND_TOP: "圆弧顶",    PatternType.ROUND_BOTTOM: "圆弧底",    PatternType.OTHER: "其他形态",}class StockPatternItem(BaseModel):    ts_code: str    pattern_type: int    pattern_name: str    curr_return: Optional[float]    prev_return: Optional[float]class PatternResponse(BaseModel):    period_type: str    curr_start: date    curr_end: date    prev_start: date    prev_end: date    data: Dict[int, List[StockPatternItem]]  # pattern_type -> list@app.get("/api/patterns", response_model=PatternResponse)def get_patterns(    period_type: str = Query(..., regex="^(3m|6m|9m|12m|custom)$"),    start_date: Optional[date] = None,    end_date: Optional[date] = None,):    latest_dt = get_latest_trade_date()    if latest_dt is None:        raise RuntimeError("数据库中尚无交易数据")    # 计算周期    if period_type in ("3m", "6m", "9m", "12m"):        months = int(period_type.replace("m", ""))        (curr_start, curr_end), (prev_start, prev_end) = get_period_windows(latest_dt, months)    else:        if not start_date or not end_date:            raise ValueError("自定义周期需要提供 start_date 和 end_date")        curr_start, curr_end = start_date, end_date        # 上一个周期：向前平移同长度        delta_days = (curr_end - curr_start).days + 1        prev_end = curr_start - timedelta(days=1)        prev_start = prev_end - timedelta(days=delta_days - 1)    ts_codes = get_all_ts_codes()    result: Dict[int, List[StockPatternItem]] = {t.value: [] for t in PatternType}    for code in ts_codes:        # 为了后续模型，当前分类一般使用“当前周期数据”        df_curr = get_stock_ohlc_in_range(code, curr_start, curr_end)        df_prev = get_stock_ohlc_in_range(code, prev_start, prev_end)        if df_curr.empty:            continue  # 没有当前周期数据就跳过        pattern = classify_pattern(df_curr, mode="rule")        curr_ret = calc_period_return(df_curr)        prev_ret = calc_period_return(df_prev) if not df_prev.empty else None        item = StockPatternItem(            ts_code=code,            pattern_type=int(pattern.value),            pattern_name=PATTERN_NAME_MAP[pattern],            curr_return=curr_ret,            prev_return=prev_ret,        )        result[int(pattern.value)].append(item)    return PatternResponse(        period_type=period_type,        curr_start=curr_start,        curr_end=curr_end,        prev_start=prev_start,        prev_end=prev_end,        data=result,    )
启动服务（在项目根目录执行）：
uvicorn PatternAnalysis.api_service:app --host 0.0.0.0 --port 8000
六、增量数据与“个股数据补全 → 任务重启”
建议增加一张元数据表（或用现有任务表）：
CREATE TABLE pattern_analysis_status (  ts_code       VARCHAR(255) NOT NULL,  period_type   VARCHAR(16)  NOT NULL,  -- 3m/6m/9m/12m/custom_xxx  last_trade_date DATE       NOT NULL,  -- 本次分类使用到的最后交易日  last_update_time DATETIME(6) NOT NULL,  PRIMARY KEY (ts_code, period_type));
增量逻辑：
每天（或每次批量导入日线）之后执行 incremental_jobs.py：
找到新增数据中涉及的 ts_code 列表
对每个 period_type（3m/6m/9m/12m 自定义可另行管理）：
查询 pattern_analysis_status，看该股票在此 period_type 下的 last_trade_date 是否 < 当前 stocktradetodayinfo 中的最新交易日
若是，则调用上面的分类流程对该股票重算一次（只需要针对这只股票），并更新 pattern_analysis_status
对于 Web 或 API 查询：
可以直接在线现算（接口形式如上），也可以查询缓存的结果表
若使用缓存表，则在增量任务中把分类结果落表，如 pattern_analysis_result，接口只读这张表
这样做可以：
避免每次查询都全量扫描所有股票
当有新日线到来时，只对新增/更新的股票重新跑分类逻辑
若将来 AI 模型重训后，想“全量重跑”某个周期的分类，可以写一个单独的批量脚本重算所有股票。
七、Web 界面（应用层）
在 Web 层只需要调用 /api/patterns：
基础功能：
下拉框选择：3 个月 / 6 个月 / 9 个月 / 1 年 / 自定义
若选自定义，则选择开始结束日期
展示一个 Tab 或 Accordion：
每个形态一栏：单边上涨 / 单边下跌 / 上升三角形 / ... / 其他形态
每栏内是股票列表：ts_code | 当前周期涨跌幅 | 上一周期涨跌幅，支持排序
可选扩展：
点击某个股票弹出 K 线图（最近一年）+ 标出识别到的形态区域
显示模型置信度、技术指标值等
